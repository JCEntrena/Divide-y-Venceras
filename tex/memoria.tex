%%%
% Modificación de una plantilla de Latex para adaptarla al castellano.
%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Thin Sectioned Essay
% LaTeX Template
% Version 1.0 (3/8/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original Author:
% Nicolas Diaz (nsdiaz@uc.cl) with extensive modifications by:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a4paper, 11pt]{article} % Font size (can be 10pt, 11pt or 12pt) and paper size (remove a4paper for US letter paper)

\usepackage[protrusion=true,expansion=true]{microtype} % Better typography
\usepackage{graphicx} % Required for including pictures
\usepackage[usenames,dvipsnames]{color} % Coloring code
\usepackage{wrapfig} % Allows in-line images
\usepackage[utf8]{inputenc}

% sudo apt-get install texlive-lang-spanish
\usepackage[spanish]{babel} % English language/hyphenation
\selectlanguage{spanish}
% Hay que pelearse con babel-spanish para el alineamiento del punto decimal
\decimalpoint
\usepackage{dcolumn}
\newcolumntype{d}[1]{D{.}{\esperiod}{#1}}
\makeatletter
\addto\shorthandsspanish{\let\esperiod\es@period@code}
\makeatother

\usepackage{longtable}
\usepackage{tabu}
\usepackage{supertabular}

\usepackage{multicol}
\newsavebox\ltmcbox

% Para algoritmos
\usepackage{algorithm}
\usepackage{algorithmic}
\input{spanishAlgorithmic.tex}

\usepackage[section]{placeins} % Para gráficas en su sección.
\usepackage{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Required for accented characters
\newenvironment{allintypewriter}{\ttfamily}{\par}
\setlength{\parindent}{0pt}
\parskip=8pt
\linespread{1.05} % Change line spacing here, Palatino benefits from a slight increase by default

\makeatletter
\renewcommand\@biblabel[1]{\textbf{#1.}} % Change the square brackets for each bibliography item from '[1]' to '1.'
\renewcommand{\@listI}{\itemsep=0pt} % Reduce the space between items in the itemize and enumerate environments and the bibliography
\newcommand{\imagen}[2]{\begin{center} \includegraphics[width=90mm]{#1} \\#2 \end{center}}

\renewcommand{\maketitle}{ % Customize the title - do not edit title and author name here, see the TITLE block below
\begin{flushright} % Right align
{\LARGE\@title} % Increase the font size of the title

\vspace{50pt} % Some vertical space between the title and author name

{\large\@author} % Author name
\\\@date % Date

\vspace{40pt} % Some vertical space between the author block and abstract
\end{flushright}
}

%----------------------------------------------------------------------------------------
%	TITLE
%----------------------------------------------------------------------------------------

\title{\textbf{Práctica 2}\\ % Title
Divide y vencerás} % Subtitle

\author{\textsc{Óscar Bermúdez,\\Francisco David Charte,\\Ignacio Cordón,\\José Carlos Entrena,\\Mario Román} % Author
\\{\textit{Universidad de Granada}}} % Institution

\date{\today} % Date

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title section

\renewcommand{\abstractname}{Resumen} % Uncomment to change the name of the abstract to something else
\begin{abstract}

\end{abstract}
{\parskip=2pt
\tableofcontents
}
\pagebreak

\section {Suma de $n$ números}
\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	\texttt{v}, lista de $n$ números\\
     	\IF{$n$==1}
	  \RETURN {\texttt{v[0]}}
	\ELSE
	  \RETURN {\texttt{Suma(\{v[1]\ldots v[n/2]\}) + Suma (\{v[n/2+1]\ldots v[n]\})}}
    	\ENDIF \\\
	\end{algorithmic}
    \caption{Suma de $n$ números}
    \label{suma}
\end{algorithm}

\section {Multiplicación de números grandes (adaptado a binario)}

Llamamos longitud en bits de un número entero positivo $x=x_{n}x_{n-1}\ldots x_1)_b \quad \\ x_i \in \{0,1\}$
a $\max\{i\in \{1\ldots n\} : x_i = 1\}$ 
\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	\texttt{x,y, números enteros positivos}\\\
        	
        \STATE{\texttt{n}:= menor de las longitudes en bits de \texttt{x,y}}
     	\IF{\texttt{longitud} $<$ 2}
     		\RETURN{$x\cdot y$}
    	\ELSE
	  \STATE{\texttt{(a,c):= $\left\lceil \frac{n}{2}\right\rceil$} bits superiores de \texttt{(x,y)}\\
		 \texttt{(b,d):= $\left\lfloor \frac{n}{2}\right\rfloor$} bits inferiores de \texttt{(x,y)}}
	  \STATE{Calculamos \texttt{a$\cdot$c} y \texttt{b$\cdot$d} llamando recursivamente al algoritmo}
	  \ENDIF \\\
    	\RETURN{$ac\cdot 2^{\left\lceil n/2 \right\rceil \cdot 2} +[(a-b)\cdot(d-c) +ac +bd]\cdot \left\lfloor n/2\right\rfloor + bd$}
	\end{algorithmic}
    \caption{Multiplicación de números grandes}
    \label{multiplicacion}
\end{algorithm}

\section {$K$-ésimo menor elemento de un vector}
  \subsection{Algoritmo}
    Nos basaremos en una idea similar a la usada para el algoritmo de ordenación \textit{Quicksort}.
    Seleccionaremos un elemento pivote y dividiremos la lista en dos partes, una con los elementos menores
    a él y otra con los elementos mayores que él.
    
    Así, el pivote quedará en su posición ordenada. Si ésta es
    la posición $k$, habremos acabado; en otro caso, sólo tendremos que buscar recursivamente sobre la 
    sublista de elementos mayores, si el índice es menor que $k$; o sobre la sublista de elementos menores, si el
    índice es mayor que $k$.
    
    \begin{algorithm}[H]
	\begin{algorithmic}[1]
		  \REQUIRE \ \\
		  \texttt{v}, vector de números\\
		  \texttt{k}, entero postivo\\\
	  \STATE{\texttt{pivote$\leftarrow$ v[0]}}     	
	  \STATE{Definimos:\\
		\texttt{menores}=$\{x\in v : x<pivote\}$\\
		\texttt{iguales}=$\{x\in v : x=pivote\}$\\
		\texttt{mayores}=$\{x\in v : x>pivote\}$}
	  \\\
	  \IF{\texttt{k<\#menores}}
	    \RETURN {\texttt{k-ésimo(menores,k)}}
	  \ELSIF{\texttt{k<(\#menores+\#iguales)}}
	    \RETURN {pivote}
	  \ELSE
	    \RETURN {\texttt{k-ésimo(mayores,k-(\#menores+\#iguales))}}
	  \ENDIF
	\end{algorithmic}
      \caption{$k$-ésimo menor elemento de un vector. Primera versión.}
      \label{kesimo}
    \end{algorithm}

    Nótese como la elección del pivote en el algoritmo original es arbitraria. Esta elección condiciona la eficiencia de
    todo el algoritmo. El pivote óptimo para el algoritmo sería la mediana de los elementos de la lista, pero su determinación
    es costosa. En lugar de usar la mediana, buscamos un elemento que se aproxime lo suficiente a la mediana para asegurarnos
    la mejora de eficiencia en el algoritmo.
    
    Se propone como algoritmo de obtención del pivote dividir la lista en sublistas de $5$ elementos, de las que se obtendrá
    la mediana usando cualquier algoritmo de ordenación. Sobre las medianas obtenidas, se aplica recursivamente el algoritmo.
    \begin{algorithm}[H]
      \begin{algorithmic}
	    \REQUIRE \ \\
	    \texttt{v}, vector de números \\\
	  
	  \IF{\texttt{v.size >\ 5}}
	    \STATE{\texttt{sublistas} $\leftarrow$ $[v[0..4],v[5..9],\dots,v[5\left\lceil\frac{n}{5}\right\rceil..n]]$} \\
	    \STATE{\texttt{w} $\leftarrow$ \{ \texttt{pivote($s_i$)} $\ | \ $ $s_i$ $\in$ \texttt{sublistas} \} } \\
	    \RETURN{\texttt{pivote(w)}}
	  \ELSE
	    \STATE{Ordenar \texttt{v}} \\
	    \RETURN{\texttt{v[2]}} \\
	  \ENDIF
      \end{algorithmic}
      \caption{Selección del pivote.}
      \label{median-of-medians}
    \end{algorithm}

  \subsection{Análisis de eficiencia.}
    \subsubsection{Elección arbitraria del pivote.}
      El algoritmo realiza una partición alrededor del pivote en tiempo $\mathbb{O}(n)$ y pasa a aplicar el algoritmo
      en uno de los dos lados de la lista dividida. Cada uno tendrá tanta posibilidad de ser elegido como elementos tenga,
      por lo que podemos considerar:
      \begin{equation}
	T(n) = n + \frac{1}{n}\left( \right)
      \end{equation}


\section {Elemento mayoritario}
Se denomina \textit{elemento mayoritario} de una lista a aquel que aparece más de $n/2$ veces, donde $n$ es el tamaño de la lista.
El problema reside en eliminar la necesidad de contar todas las ocurrencias de cada uno de los elementos, de forma que podamos conocer el mayoritario más eficientemente.
Para ello, utilizaremos la siguiente estrategia:

\begin{itemize}
\item Tomamos parejas de elementos consecutivos en la lista.
\item Para cada pareja, comprobaremos cuáles tienen sus dos elementos iguales.
\item Creamos una nueva lista con los elementos correspondientes a cada pareja de valores repetidos.
\end{itemize}

Efectivamente, esta estrategia nos asegura que, de existir un elemento mayoritario en la lista original, entonces será el elemento mayoritario de la nueva lista. Veamos por tanto el algoritmo seguido para la resolución del problema:

\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	\texttt{elem}, vector de elementos\\\
     	\IF{\texttt{\#elem} <\ 3}
	     	\IF{\texttt{\#elem} <\ 2 \OR \texttt{elem[0]} == \texttt{elem[1]}}
    	 		\RETURN{\texttt{v[0]}} 
     		\ELSE
     			\RETURN{\texttt{NULO}}
     		\ENDIF \\\
     		
     		\STATE{Crear un nuevo vector \texttt{repet}}
     		\FORALL{\texttt{e} \textbf{en} \texttt{elem}}
	     		\IF{\texttt{e} es el último \OR \texttt{e} == siguiente de \texttt{e}}
		     		\STATE{Añadir \texttt{e} a \texttt{repet}}
	     		\ENDIF
     		\ENDFOR
    	\ENDIF \\\
    	\RETURN{elemento mayoritario de \texttt{repet} (llamada recursiva)}
	\end{algorithmic}
    \caption{Búsqueda del elemento mayoritario}
    \label{mayoritario}
\end{algorithm}
\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	\texttt{elem}, vector de elementos\\
        	\texttt{may}, candidato a mayoritario\\\
    	\IF{ocurrencias de \texttt{may} en \texttt{elem} >\ \#\texttt{elem}/2}
     		\RETURN{\texttt{may}}
     	\ELSE
     		\RETURN{\texttt{NULO}}
    	\ENDIF \\
	\end{algorithmic}
    \caption{Comprobación del elemento mayoritario}
    \label{checkmay}
\end{algorithm}

\section {Tornillos y tuercas}
\section {Compraventa de acciones}

\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	\texttt{lorem}\\\
     	\IF{ipsum}
     		\STATE{dolor sit amet}
    	\ENDIF \\\
    	\STATE{consectetur adipiscing elit}
	\end{algorithmic}
    \caption{Algoritmo de prueba}
    \label{algoritmo}
\end{algorithm}

\end{document}