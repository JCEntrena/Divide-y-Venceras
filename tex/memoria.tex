%%%
% Modificación de una plantilla de Latex para adaptarla al castellano.
%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Thin Sectioned Essay
% LaTeX Template
% Version 1.0 (3/8/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original Author:
% Nicolas Diaz (nsdiaz@uc.cl) with extensive modifications by:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a4paper, 11pt]{article} % Font size (can be 10pt, 11pt or 12pt) and paper size (remove a4paper for US letter paper)

\usepackage[protrusion=true,expansion=true]{microtype} % Better typography
\usepackage{graphicx} % Required for including pictures
\usepackage[usenames,dvipsnames]{color} % Coloring code
\usepackage{wrapfig} % Allows in-line images
\usepackage[utf8]{inputenc}

% sudo apt-get install texlive-lang-spanish
\usepackage[spanish]{babel} % English language/hyphenation
\selectlanguage{spanish}
% Hay que pelearse con babel-spanish para el alineamiento del punto decimal
\decimalpoint
\usepackage{dcolumn}
\newcolumntype{d}[1]{D{.}{\esperiod}{#1}}
\makeatletter
\addto\shorthandsspanish{\let\esperiod\es@period@code}
\makeatother

\usepackage{longtable}
\usepackage{tabu}
\usepackage{supertabular}

\usepackage{multicol}
\newsavebox\ltmcbox

% Para algoritmos
\usepackage{algorithm}
\usepackage{algorithmic}
\input{spanishAlgorithmic.tex}

\usepackage[section]{placeins} % Para gráficas en su sección.
\usepackage{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Required for accented characters
\newenvironment{allintypewriter}{\ttfamily}{\par}
\setlength{\parindent}{0pt}
\parskip=8pt
\linespread{1.05} % Change line spacing here, Palatino benefits from a slight increase by default

\makeatletter
\renewcommand\@biblabel[1]{\textbf{#1.}} % Change the square brackets for each bibliography item from '[1]' to '1.'
\renewcommand{\@listI}{\itemsep=0pt} % Reduce the space between items in the itemize and enumerate environments and the bibliography
\newcommand{\imagen}[2]{\begin{center} \includegraphics[width=90mm]{#1} \\#2 \end{center}}

\renewcommand{\maketitle}{ % Customize the title - do not edit title and author name here, see the TITLE block below
\begin{flushright} % Right align
{\LARGE\@title} % Increase the font size of the title

\vspace{50pt} % Some vertical space between the title and author name

{\large\@author} % Author name
\\\@date % Date

\vspace{40pt} % Some vertical space between the author block and abstract
\end{flushright}
}

%----------------------------------------------------------------------------------------
%	TITLE
%----------------------------------------------------------------------------------------

\title{\textbf{Práctica 2}\\ % Title
Divide y vencerás} % Subtitle

\author{\textsc{Óscar Bermúdez,\\Francisco David Charte,\\Ignacio Cordón,\\José Carlos Entrena,\\Mario Román} % Author
\\{\textit{Universidad de Granada}}} % Institution

\date{\today} % Date

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title section

\renewcommand{\abstractname}{Resumen} % Uncomment to change the name of the abstract to something else
\begin{abstract}

\end{abstract}
{\parskip=2pt
\tableofcontents
}
\pagebreak

\section {Suma de $n$ números}
\subsection{Algoritmo}
\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	\texttt{v}, lista de $n$ números\\
     	\IF{$n$==1}
	  \RETURN {\texttt{v[0]}}
	\ELSE
	  \RETURN {\texttt{Suma(\{v[1]\ldots v[n/2]\}) + Suma (\{v[n/2+1]\ldots v[n]\})}}
    	\ENDIF \\\
	\end{algorithmic}
    \caption{Suma de $n$ números}
    \label{suma}
\end{algorithm}

\subsection{Análisis de eficiencia}
El algoritmo responde a una recurrencia de la forma:
\begin{equation}
 T(n)=\left\lbrace
	    \begin{array}{lr}
            1 & n=1\\
            2\cdot T\left(\frac{n}{2}\right) & n>1\\
            \end{array}
	    \right.
\end{equation}

Resolviendo la recurrencia, tenemos:
\begin{equation}
 T(n)=n\quad \forall n\in \mathbb{N}
\end{equation}

Es claro que al tener que recorrer todas las componentes (es necesario leer las posiciones
del vector, para poder sumarlas), el mejor algoritmo que se puede ejecutar en un único core 
será de complejidad $\mathcal{O}(n)$. En el caso de un único core, por tanto, no supone ninguna
mejora el realizar el algoritmo Divide y Vencerás; más aún, este algoritmo será más lento que el
iterativo, por la necesidad de crear marcos de pila nuevos para cada llamada a la función\\
Para un procesador vectorial (SIMD), de nuevo encontramos que el algoritmo iterativo convencional
(recorrer todo el vector e ir acumulando en una variable suma) sería más eficiente que el Divide y Vencerás.
Únicamente encontraríamos mejora si el computador fuese de tipo MIMD, ya que en dicho caso podríamos crear
varias hebras y que cada una de ellas se ocupara de atender una llamada a la recurrencia en un procesador distinto.


\section {Multiplicación de números grandes (adaptado a binario)}
\subsection{Algoritmo}
Llamamos longitud en bits de un número entero positivo $x=x_{n}x_{n-1}\ldots x_1)_b \quad \\ x_i \in \{0,1\}$
a $\max\{i\in \{1\ldots n\} : x_i = 1\}$
Denotamos por \texttt{x $>>$ y} y \texttt{x $<<$ y} a las rotaciones a derecha e izquierda $y$ posiciones
de los bits de un número entero $x$
\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	\texttt{x,y, números enteros positivos}\\\
	\IF{[x<0 \AND y<0] \OR [x>0 \AND y>0] }
	  \STATE{\texttt{signo=}1}
	\ELSE
	  \STATE{\texttt{signo=}-1}
	\ENDIF\\\
	\STATE{\texttt{(x,y):=(|x|,|y|)}}
        \STATE{\texttt{n}:= menor de las longitudes en bits de \texttt{x,y}}
     	\\\
     	\IF{\texttt{longitud} $<$ 2}
     		\RETURN{$x\cdot y \cdot \texttt{signo}$}
    	\ELSE
	  \STATE{\texttt{(a,c):= $\left\lceil \frac{n}{2}\right\rceil$} bits superiores de \texttt{(x,y)}\\
		 \texttt{(b,d):= $\left\lfloor \frac{n}{2}\right\rfloor$} bits inferiores de \texttt{(x,y)}}
	  \STATE{Calculamos \texttt{a$\cdot$c} y \texttt{b$\cdot$d} llamando recursivamente al algoritmo}
	\ENDIF \\\
    	\RETURN{\\\ $\bigg( ac << (\left\lceil n/2 \right\rceil \cdot 2) +
    	\bigg[\texttt{Producto\_divide\_venceras}((a-b),(d-c)) +ac +bd\bigg]\cdot \left\lfloor n/2\right\rfloor + 
    	bd \bigg) \cdot \texttt{signo}$
    	}
	\end{algorithmic}
    \caption{Algoritmo de Karatsuba}
    \label{multiplicacion}
\end{algorithm}

\subsection{Análisis de eficiencia}
El algoritmo convencional de multiplicación de dos enteros de $n$ cifras, tiene una eficiencia de $\mathcal{O}(n^2)$
El algoritmo sigue la siguiente recurrencia:
\begin{equation}\label{rec}
 T(n)=\left\lbrace
	    \begin{array}{lr}
            1 & n=1\\
            3\cdot T\left(\frac{n}{2}\right) + M\cdot n & n>1\\
            \end{array}
	    \right.
\end{equation}

donde $M\in\mathbb{R}$ es una constante, y el sumando $n$ del caso $n>1$ de la recurrencia viene dado por el cálculo
de la longitud de los números en bits, las sumas y restas que se efectúan en el algoritmo, y las rotaciones.

Para resolver la recurrencia, efectuamos el cambio de variable $n=2^k$:
\begin{equation}\label{prodcv}
 T(2^k)=3\cdot T(2^{k-1}) + M\cdot 2^k
\end{equation}
y resolvemos: 

\begin{equation}
x_k=3\cdot x_{k-1}+M\cdot 2^k
\end{equation}
Calculamos una solución particular de la recurrencia no homogénea:
$$A\cdot 2^k - 3\cdot A \cdot 2^{k-1}=-A\cdot 2^{k-1}=M2^k \leftrightarrow A=-2M$$
y por tanto: $x_k=-2M \cdot 2^k$ es solución particular\\
Calculamos ahora la solución general a la recurrencia homogénea:
$$ x_k-3\cdot x_{k-1}=0$$
que tiene por polinomio característico a $x-3$. Por tanto, la solución general de la
recurrencia homogénea es:
$$ x_k= p\cdot 3^k\qquad p\in\mathbb{R}$$
\\\
Concluimos que la solución a la recurrencia \ref{prodcv} es: 
\begin{equation}
x_k = p \cdot 2^k + q \cdot 3^k \qquad p,q \in \mathbb{R}
\end{equation}
y deshaciendo el cambio en variable, llegamos a la solución de \ref{rec}:
\begin{eqnarray*}
T(n)=p \cdot 2^{log_2(n)} + q \cdot 3^{log_2(n)} = p \cdot 2^{log_2(n)} +\\
q \cdot 3^{\frac{log_3(n)}{log_2(n)}}=p \cdot 2^{log_2(n)} + q \cdot n^{\frac{log3)}{log2}} \quad \in \mathcal{O}(n^{1.585})
\end{eqnarray*}

Por tanto el algoritmo de Karatsuba es mejor asintóticamente hablando que el convencional para efectuar
el producto de dos números

\section {$K$-ésimo menor elemento de un vector}
  \subsection{Algoritmo}
    Nos basaremos en una idea similar a la usada para el algoritmo de ordenación \textit{Quicksort}.
    Seleccionaremos un elemento pivote y dividiremos la lista en dos partes, una con los elementos menores
    a él y otra con los elementos mayores que él.
    
    Así, el pivote quedará en su posición ordenada. Si ésta es
    la posición $k$, habremos acabado; en otro caso, sólo tendremos que buscar recursivamente sobre la 
    sublista de elementos mayores, si el índice es menor que $k$; o sobre la sublista de elementos menores, si el
    índice es mayor que $k$.
    
    \begin{algorithm}[H]
	\begin{algorithmic}[1]
		  \REQUIRE \ \\
		  \texttt{v}, vector de números\\
		  \texttt{k}, entero postivo\\\
	  \STATE{\texttt{pivote$\leftarrow$ v[0]}}     	
	  \STATE{Definimos:\\
		\texttt{menores}=$\{x\in v : x<pivote\}$\\
		\texttt{iguales}=$\{x\in v : x=pivote\}$\\
		\texttt{mayores}=$\{x\in v : x>pivote\}$}
	  \\\
	  \IF{\texttt{k<\#menores}}
	    \RETURN {\texttt{k-ésimo(menores,k)}}
	  \ELSIF{\texttt{k<(\#menores+\#iguales)}}
	    \RETURN {pivote}
	  \ELSE
	    \RETURN {\texttt{k-ésimo(mayores,k-(\#menores+\#iguales))}}
	  \ENDIF
	\end{algorithmic}
      \caption{$k$-ésimo menor elemento de un vector. Primera versión.}
      \label{kesimo}
    \end{algorithm}

    Nótese como la elección del pivote en el algoritmo original es arbitraria. Esta elección condiciona la eficiencia de
    todo el algoritmo. El pivote óptimo para el algoritmo sería la mediana de los elementos de la lista, pero su determinación
    es costosa. En lugar de usar la mediana, buscamos un elemento que se aproxime lo suficiente a la mediana para asegurarnos
    la mejora de eficiencia en el algoritmo.
    
    Se propone como algoritmo de obtención del pivote dividir la lista en sublistas de $5$ elementos, de las que se obtendrá
    la mediana usando cualquier algoritmo de ordenación. Sobre las medianas obtenidas, se aplica recursivamente el algoritmo.
    \begin{algorithm}[H]
      \begin{algorithmic}
	    \REQUIRE \ \\
	    \texttt{v}, vector de números \\\
	  
	  \IF{\texttt{v.size >\ 5}}
	    \STATE{\texttt{sublistas} $\leftarrow$ $[v[0..4],v[5..9],\dots,v[(n-4)..n]]$} \\
	    \STATE{\texttt{w} $\leftarrow$ \{ \texttt{pivote($s_i$)} $\ | \ $ $s_i$ $\in$ \texttt{sublistas} \} } \\
	    \RETURN{\texttt{pivote(w)}}
	  \ELSE
	    \STATE{Ordenar \texttt{v}} \\
	    \RETURN{\texttt{v[2]}} \\
	  \ENDIF
      \end{algorithmic}
      \caption{Selección del pivote.}
      \label{median-of-medians}
    \end{algorithm}

  \subsection{Análisis de eficiencia.}
    \subsubsection{Elección arbitraria del pivote.}
      El caso medio del algoritmo es lineal. Puede comprobarse siguiendo un razonamiento similar al aplicado para 
      calcular el caso medio en \textit{Quicksort}, podemos analizar su eficiencia.
    
      El algoritmo realiza una partición alrededor del pivote en tiempo $\mathcal{O}(n)$ y pasa a aplicar el algoritmo
      en uno de los dos lados de la lista dividida. Cada uno tendrá tanta posibilidad de ser elegido como elementos tenga,
      por lo que podemos considerar:
      \begin{equation}
	T(n) = n + \frac{1}{n}\sum_{i=0}^{n-1}\left( \frac{i}{n}T(i) + \frac{n-1-i}{n}T(n-1-i) \right)
      \end{equation}
      Reordenando y multiplicando por $n^2$ obtenemos:
      \begin{equation}
        n^2T(n) = n^3 + 2\sum^{n-1}_{i=1} \left( i T(i) \right)
      \end{equation}
      Para resolver la ecuación no homogénea, evaluamos en $n-1$ y restamos, obteniendo:
      \begin{equation}
        n^2T(n) = (n^2-1)T(n-1) + 3n^2 - 3n + 1
      \end{equation}
      Ahora consideramos $S(n) = \frac{nT(n)}{n+1}$, y obtenemos la ecuación:
      \begin{equation}
        S(n) = S(n-1) + 3\frac{n-1}{n+1} + \frac{1}{n} - \frac{1}{n-1} \\
      \end{equation}
      Que se puede resolver inductivamente usando la serie armónica.
      \begin{eqnarray}
        \lefteqn{S(n) = \sum_{i=2}^n{\left( 3 - \frac{6}{i+1} + \frac{1}{i} - \frac{1}{i-1} \right)} = }\\ 
        &&\mathcal{O}(n) - \mathcal{O}(log(n)) + \mathcal{O}(log(n)) - \mathcal{O}(log(n)) = \mathcal{O}(n)
      \end{eqnarray}
      De donde, por ser $\frac{n+1}{n}\longrightarrow 1$ despejamos de nuevo $T(n)$ como:
      \begin{equation}
        T(n) =  \mathcal{O}(n)
      \end{equation}

      Sin embargo, el caso peor con elección arbitraria es $\mathcal{O}(n^2)$. Trivialmente, escogiendo a cada paso el mínimo de los elementos restantes como pivote
      mientras que buscamos el elemento máximo de la lista, nos lleva a aplicar la partición $n$ veces, cada una de ellas con coste $\mathcal{O}(n)$.
    

\section {Elemento mayoritario}
Se denomina \textit{elemento mayoritario} de una lista a aquel que aparece más de $n/2$ veces, donde $n$ es el tamaño de la lista.
El problema reside en eliminar la necesidad de contar todas las ocurrencias de cada uno de los elementos, de forma que podamos conocer el mayoritario más eficientemente.
Para ello, utilizaremos la siguiente estrategia:

\begin{itemize}
\item Tomamos parejas de elementos consecutivos en la lista.
\item Para cada pareja, comprobaremos cuáles tienen sus dos elementos iguales.
\item Creamos una nueva lista con los elementos correspondientes a cada pareja de valores repetidos.
\end{itemize}

Efectivamente, esta estrategia nos asegura que, de existir un elemento mayoritario en la lista original, entonces será el elemento mayoritario de la nueva lista. Veamos por tanto el algoritmo seguido para la resolución del problema:

\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	\texttt{elem}, vector de elementos\\\
     	\IF{\texttt{\#elem} <\ 3}
	     	\IF{\texttt{\#elem} <\ 2 \OR \texttt{elem[0]} == \texttt{elem[1]}}
    	 		\RETURN{\texttt{elem[0]}} 
     		\ELSE
     			\RETURN{\texttt{NULO}}
     		\ENDIF \\\
     		
     		\STATE{Crear un nuevo vector \texttt{repet}}
     		\FORALL{\texttt{e} \textbf{en} \texttt{elem}}
	     		\IF{\texttt{e} es el último \OR \texttt{e} == siguiente de \texttt{e}}
		     		\STATE{Añadir \texttt{e} a \texttt{repet}}
	     		\ENDIF
     		\ENDFOR
    	\ENDIF \\\
    	\RETURN{elemento mayoritario de \texttt{repet} (llamada recursiva)}
	\end{algorithmic}
    \caption{Búsqueda del elemento mayoritario}
    \label{mayoritario}
\end{algorithm}
\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	\texttt{elem}, vector de elementos\\
        	\texttt{may}, candidato a mayoritario\\\
    	\IF{ocurrencias de \texttt{may} en \texttt{elem} >\ \#\texttt{elem}/2}
     		\RETURN{\texttt{may}}
     	\ELSE
     		\RETURN{\texttt{NULO}}
    	\ENDIF \\
	\end{algorithmic}
    \caption{Comprobación del elemento mayoritario}
    \label{checkmay}
\end{algorithm}

\section {Tornillos y tuercas}
    Tenemos dos listas cuyos elementos están emparejados con uno y sólo uno de los elementos de la otra lista.
    
    De nuevo, vamos a utilizar un procedimiento similar al usado por el \textit{Quicksort}.
    
    Seleccionaremos un elemento pivote de una lista y dividiremos la lista contraria en tres partes, una con los elementos menores a él, otra con los mayores, y su pareja.
    
    Y utilizando la pareja como pivote, dividimos la primera lista en elementos menores y mayores a la pareja(y, por tanto, al elemento que cogimos antes).
    
    Una vez tenemos la separación en dos partes de las dos listas, procedemos a ordenar cada una de las mitades con la mitad correspondiente de la otra lista(elementos menores al pivote con elementos menores a su pareja, y elementos mayores al pivote con elementos mayores a su pareja).
\begin{algorithm}[H]
	\begin{algorithmic}[1]
	  \REQUIRE \ \\
	    \texttt{a, b, listas emparejadas de $n$ números}\\
	  \IF{$n$==0}
	    \RETURN {\texttt{[]}}
	  \ELSE
	    \STATE{\texttt{pivote$\leftarrow$ a[0]}}
	    \STATE{Definimos:\\
	      \texttt{pareja}=$\{y\in b : y=pivote\}$, que será único por las condiciones del problema\\
	      \texttt{menores de b}=$\{y\in b : y<pivote\}$\\
	      \texttt{mayores de b}=$\{y\in b : y>pivote\}$\\
	      \texttt{menores de a}=$\{x\in a : x<pareja\}$\\
	      \texttt{mayores de a}=$\{x\in a : x>pareja\}$\\}
	  \IF{\#\texttt{menores de b} != 0}
	    \STATE{\texttt{Ordenar(menores de b, menores de a)}}
	  \ENDIF \\
	  \IF{\#\texttt{mayores de b} != 0}
	    \STATE{\texttt{Ordenar(mayores de b, mayores de a)}}
	  \ENDIF \\
	  
	  \RETURN {\texttt{[(menores de a + pivote + mayores de a), \\ (menores de b + pareja + mayores de b)]}}
	  \ENDIF \\\
	\end{algorithmic}
    \caption{Tornillos y tuercas}
    \label{TyT}
\end{algorithm}

Además, al igual que en el caso de la búsqueda del $K$-ésimo menor elemento, podemos mejorar la eficiencia del algoritmo usando el algoritmo ~\ref{median-of-medians} para la elección del pivote.

\section {Compraventa de acciones}
	% (Comentario Mario)
	% ¿Necesitamos suponerlos double? De hecho, con que sean datos donde haya definida relación de orden...
	Tenemos un array con valores numéricos (que suponemos double) y queremos calcular la mayor diferencia entre dos elementos a y b, 
	esto es, maximizar b-a, con la condición de que la posición de b sea mayor que la de a. 
	
	Para ello vamos a utilizar un algoritmo recursivo. La idea de este algoritmo es la siguiente: Calculamos el mínimo y el máximo del 
	vector. Si el mínimo está antes que el máximo, hemos terminado, solo queda devolver sus posiciones. Si no es así, el vector queda 
	dividido en tres partes: Inicio-Máximo, Máximo+1-Minimo-1, y Mínimo-Final. En los trozos de los extremos podemos calcular la ganancia 
	directamente (calculando un mínimo en la primera y un máximo en la última), y para el trozo restante llamamos a la función de forma 
	recursiva. Después hay que comprobar cuál es el óptimo y quedarnos con su solución. 
	
	%(Comentario de JC)
	% He decidido comprobar que el vector no esté ordenado de mayor a menor desde el principio, ya que facilita mucho las cosas. De todas formas no sé si este algoritmo es óptimo, así que echadle un vistazo. 
	

\begin{algorithm}[H]
	\begin{algorithmic}[1]
		\REQUIRE \ \\
        	\texttt{Array}\\\
     	\IF{Ordenado}
     		\RETURN {\texttt{Punteros a NULL}}
     	\ELSE
     		\STATE{Calculamos el mínimo y el máximo}
     		\IF{Pos[mínimo] < Pos[máximo]}
     			\RETURN{Posiciones}
     		\ENDIF \\\
     		\ELSE
     			\STATE{Hacemos la división en trozos. Llamamos a la función de forma recursiva y nos quedamos con la mejor solución}
    	\ENDIF \\\
	\end{algorithmic}
    \caption{Compraventa de Acciones}
    \label{algoritmo}
\end{algorithm}

\end{document}